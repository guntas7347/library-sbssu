generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// prisma:warn In production, we recommend using `prisma generate --no-engine` (See: `prisma generate --help`)

enum Gender {
  male
  female
  other
}

model Member {
  id                 String        @id @default(uuid())
  membershipId       String?       @unique
  applicationId      String        @unique
  authId             String?
  rollNumber         String?
  fullName           String
  fatherName         String
  photo              String
  batch              String
  email              String
  phoneNumber        String
  cast               String        @default("general")
  gender             Gender        @default(male)
  dob                DateTime
  program            String
  specialization     String
  streetAddress      String
  city               String
  state              String
  pinCode            String
  subscribeToUpdates Boolean
  libraryCards       LibraryCard[]
  memberType         String
  status             String        @default("applied")
  balance            Int           @default(0)
  transactions       Transaction[]
  Auth               Auth?
  createdAt          DateTime      @default(now())
  updatedAt          DateTime      @updatedAt
}

model LibraryCard {
  id            String         @id @default(uuid())
  member        Member         @relation(fields: [memberId], references: [id])
  memberId      String
  cardNumber    String         @unique
  status        String         @default("available")
  type          String
  expiry        DateTime
  remark        String?
  createdBy     String
  autoAlloted   Boolean        @default(false)
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
  staff         Staff?         @relation("StaffLibraryCards", fields: [createdBy], references: [id])
  issuedBooks   IssuedBook[]
  returnedBooks ReturnedBook[]
}

model Staff {
  id                   String         @id @default(uuid())
  idNumber             String         @unique
  fullName             String
  authId               String?
  phoneNumber          String?
  dateOfBirth          DateTime?
  gender               String?
  address              String?
  emergencyContact     String?
  employeeId           String?
  department           String?
  designation          String?
  joiningDate          DateTime?
  employmentStatus     String?
  photo                String?
  createdAt            DateTime       @default(now())
  libraryCards         LibraryCard[]  @relation("StaffLibraryCards")
  auth                 Auth?
  issuedBooks          IssuedBook[]   @relation("IssuedByStaff")
  returnedBooks        ReturnedBook[] @relation("ReturnedByStaff")
  returnsOfIssuedBooks ReturnedBook[] @relation("IssuedByStaffReturned")
  transactions         Transaction[]
}

model Auth {
  id                  String               @id @default(uuid())
  username            String               @unique
  password            String
  email               String
  role                String               @default("staff")
  rights              String[]             @default([])
  createdAt           DateTime             @default(now())
  updatedAt           DateTime             @updatedAt
  resetCode           String?
  resetCodeTime       DateTime?
  twoFaSecret         String
  active              Boolean              @default(true)
  userType            String
  staffId             String?              @unique
  memberId            String?              @unique
  staff               Staff?               @relation(fields: [staffId], references: [id])
  member              Member?              @relation(fields: [memberId], references: [id])
  sessionFingerprints SessionFingerprint[]
}

model SessionFingerprint {
  id              String   @id @default(uuid())
  authId          String
  fingerprintHash String   @db.VarChar(64)
  isActive        Boolean  @default(true)
  createdAt       DateTime @default(now())
  lastUsedAt      DateTime @updatedAt
  auth            Auth     @relation(fields: [authId], references: [id])

  @@index([authId, fingerprintHash, isActive])
}

model Book {
  id                 String      @id @default(uuid())
  isbn               String?
  title              String?
  author             String?
  placeAndPublishers String?
  publicationYear    String?
  edition            String?
  pages              String?
  volume             String?
  description        String?
  source             String?
  location           String?
  tags               String[]
  cost               String?
  callNumber         String?
  createdAt          DateTime    @default(now())
  updatedAt          DateTime    @updatedAt
  accessions         Accession[]
}

model Accession {
  id              String         @id @default(uuid())
  book            Book           @relation(fields: [bookId], references: [id])
  bookId          String
  condition       String?        @default("unknown")
  accessionNumber Int            @unique
  status          String         @default("available")
  category        String?
  timesIssued     Int            @default(0)
  issuedBooks     IssuedBook[]
  returnedBooks   ReturnedBook[]
}

model IssuedBook {
  id              String      @id @default(uuid())
  issueRefNumber  String      @unique
  bookAccession   Accession   @relation(fields: [bookAccessionId], references: [id])
  bookAccessionId String
  libraryCard     LibraryCard @relation(fields: [libraryCardId], references: [id])
  libraryCardId   String
  issueDate       DateTime
  dueDate         DateTime
  issuedBy        Staff       @relation("IssuedByStaff", fields: [issuedById], references: [id])
  issuedById      String
  issueRemark     String?
}

model ReturnedBook {
  id              String       @id @default(uuid())
  issueRefNumber  String       @unique
  bookAccession   Accession    @relation(fields: [bookAccessionId], references: [id])
  bookAccessionId String
  libraryCard     LibraryCard  @relation(fields: [libraryCardId], references: [id])
  libraryCardId   String
  issueDate       DateTime
  dueDate         DateTime
  returnDate      DateTime
  fine            Transaction? @relation("ReturnFine")
  fineId          String?      @unique
  issuedBy        Staff        @relation("IssuedByStaffReturned", fields: [issuedById], references: [id])
  issuedById      String
  returnedBy      Staff        @relation("ReturnedByStaff", fields: [returnedById], references: [id])
  returnedById    String
  issueRemark     String?
  returnRemark    String?
}

enum TransactionType {
  CREDIT
  DEBIT
}

model Transaction {
  id              String          @id @default(uuid())
  member          Member          @relation(fields: [memberId], references: [id])
  memberId        String
  returnedBook    ReturnedBook?   @relation("ReturnFine", fields: [returnedBookId], references: [id])
  returnedBookId  String?         @unique
  issuedBy        Staff?          @relation(fields: [issuedById], references: [id])
  issuedById      String?
  transactionType TransactionType
  category        String
  remark          String?
  amount          Int
  receiptNumber   String?
  paymentMethod   String
  closingBalance  Int
  createdAt       DateTime        @default(now())
}

model Setting {
  id           String   @id @default(uuid())
  key          String   @unique
  value        Json
  lastModified DateTime @default(now())
}

model Sequence {
  id        String @id @default(uuid())
  name      String @unique
  lastValue Int
}
